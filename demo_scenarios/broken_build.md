# Сценарий: нестабильный тест (Flaky Test)

## Ситуация

Разработчик отправил Pull Request с новой функцией генерации отчётов. В состав PR входит модульный тест `test_generate_report_id`, который проверяет уникальность генерируемых идентификаторов. Тест использует текущее время (`datetime.now()`) для формирования идентификатора.

На локальной машине тест проходит стабильно. Однако в CI он периодически падает: при трёх последовательных запусках два завершились успешно, один — с ошибкой.

---

## Фрагмент лога CI с падением теста

```
========================= test session starts ==========================
platform linux -- Python 3.11.9, pytest-8.2.0
collected 47 items

tests/test_report.py::test_validate_input PASSED           [  2%]
tests/test_report.py::test_format_output PASSED            [  4%]
tests/test_report.py::test_generate_report_id FAILED       [  6%]
tests/test_report.py::test_save_report PASSED              [  8%]
...

================================ FAILURES ================================
__________________ test_generate_report_id ___________________

    def test_generate_report_id():
        id_1 = generate_report_id()
        id_2 = generate_report_id()
>       assert id_1 != id_2, "Идентификаторы должны быть уникальными"
E       AssertionError: Идентификаторы должны быть уникальными
E       assert 'RPT-20250115-143022' != 'RPT-20250115-143022'

tests/test_report.py:34: AssertionError
===================== 1 failed, 46 passed in 12.38s =======================
```

---

## Процесс диагностики и исправления

### 1. Обнаружение нестабильности

При ревью PR ревьюер обратил внимание, что статус CI менялся между запусками. Была открыта задача с пометкой «flaky test» для расследования.

### 2. Локализация причины

Анализ исходного кода функции `generate_report_id()` показал следующее:

```python
def generate_report_id() -> str:
    now = datetime.now()
    return f"RPT-{now.strftime('%Y%m%d-%H%M%S')}"
```

Идентификатор формируется с точностью до секунды. Если два вызова функции происходят в пределах одной секунды (что вероятно на быстрых серверах CI), они возвращают одинаковое значение. На локальной машине разработчика задержка между вызовами оказывалась достаточной.

**Корневая причина:** зависимость от текущего времени с недостаточной точностью.

### 3. Исправление

Функция была переписана с использованием `uuid4`, что гарантирует уникальность без зависимости от времени:

```python
import uuid

def generate_report_id() -> str:
    now = datetime.now()
    unique_suffix = uuid.uuid4().hex[:8]
    return f"RPT-{now.strftime('%Y%m%d-%H%M%S')}-{unique_suffix}"
```

Тест был обновлён соответствующим образом:

```python
def test_generate_report_id():
    id_1 = generate_report_id()
    id_2 = generate_report_id()
    assert id_1 != id_2, "Идентификаторы должны быть уникальными"
    assert id_1.startswith("RPT-"), "Идентификатор должен начинаться с префикса RPT-"
```

После исправления тест прошёл 50 последовательных запусков без единого сбоя.

---

## Урок для команды

### Правило: нестабильный тест является блокирующей проблемой

Нестабильные тесты подрывают доверие команды к CI. Если тест периодически падает без реальных изменений в коде, разработчики начинают игнорировать красный статус и перезапускать пайплайн вместо расследования. Это приводит к пропуску настоящих ошибок.

### Применение повторных запусков (retry)

Автоматические повторные запуски тестов (`pytest-rerunfailures`) допустимы только как временная мера на период расследования. Они маскируют проблему, но не устраняют её. В данном случае повторные запуски не применялись: вместо этого была устранена корневая причина.

### Карантин (quarantine / xfail)

Если исправление требует значительного времени, допускается временная пометка теста декоратором `@pytest.mark.xfail(reason="flaky: issue #123")` с обязательной привязкой к задаче в трекере. Карантинные тесты проверяются еженедельно, и каждый из них должен быть либо исправлен, либо удалён в течение одного спринта.

### Общие рекомендации по предотвращению нестабильных тестов

1. Не использовать текущее время, случайные числа без фиксированного seed или обращения к внешним сервисам в модульных тестах.
2. Для зависимости от времени использовать фиксированные значения через `freezegun` или передачу времени в качестве параметра.
3. Для случайных данных фиксировать seed: `random.seed(42)`.
4. Для внешних сервисов использовать моки (`unittest.mock`) или записанные ответы (`responses`, `vcrpy`).
